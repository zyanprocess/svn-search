明白了。我将为你梳理整个“基于AI增强SVN文档库”的开发链路，并输出一份适用于Cursor的大模型接入prompt，详细描述实现流程、模块间协作与开发细节。

我会尽快整理完毕并回复你。

# AI增强SVN文档库解决方案设计

本方案旨在在 **不改变现有 SVN 文档管理模式** 的前提下，引入大语言模型（LLM）实现对 SVN 文档内容的智能检索和问答功能。系统将预处理 SVN 中的文档生成摘要索引，并通过 **MCP（模型上下文协议）** 集成大模型，以提供基于用户权限的问答服务。以下将从整体架构、模块交互、接口规范、关键算法、权限控制和数据设计等方面详细阐述方案。

## 整体架构概述

系统采用模块化设计，由预处理、问答接口、MCP客户端/服务端、大模型处理、数据库检索、SVN存储以及权限与审计模块组成。各模块通过明确的接口交互，实现从文档数据到问答结果的完整链路：

1. **预处理模块**：每日扫描 SVN 仓库中新建或变更的文档，调用公司内大模型 API 对文档内容进行解析，生成精简的**摘要**和**标签**信息，并存入关系型数据库供检索使用。
2. **问答接口模块**：提供用户提问的入口接口，可以是现有知识库网页中的对话窗口，或IDE中的插件界面。该接口通过 WebSocket 等方式将用户自然语言问题发送给后台 MCP 客户端。
3. **MCP客户端模块**：例如使用开源 AI 助手 **DeepChat** 等，它通过 MCP（Model Context Protocol）标准接入大模型和工具。MCP客户端接收来自问答接口的问题，将其转发给大模型进行处理，并负责将大模型返回的答案传回给用户界面。
4. **大模型任务分解模块**：大模型接收到用户问题后，首先进行语义解析，判断问题意图，并**规划检索和解答步骤**。通过对问题的理解，大模型确定需要查询哪些文档或知识，并将任务分解为检索数据库、读取文档、综合回答等子任务。
5. **数据库检索模块**：大模型通过 MCP 工具或后台服务访问预处理得到的**文档摘要/标签数据库**。根据大模型解析出的关键词、标签或语义向量，对数据库进行查询匹配，检索出**候选文档列表**（含摘要、标签等元数据），再结合用户权限过滤，只返回用户有权限查看的文档结果集。
6. **SVN文档访问模块**：利用 **Office-Editor-MCP** 等 MCP 服务端工具，系统从 SVN 仓库中读取目标文档的完整内容。对于 Word/Excel/PPT 等二进制办公文档，由 Office-Editor-MCP 充当桥梁，将Office文档操作暴露为工具供 AI 使用；对于文本文件，可直接读取。大模型获取文档全文或相关片段后，进行深入解读、信息抽取和答案生成。
7. **权限控制与溯源模块**：整个流程中严格执行 SVN 的权限控制，只允许检索和访问**用户有权查看**的文档内容。每次问答的请求、使用的数据来源（文档）及生成的应答都会记录在日志中，便于事后审计和追溯数据来源，确保合规。

上述流程可以总结为：用户通过前端提出问题，经由 MCP 客户端协调大模型进行数据库搜索和文档读取，最后由大模型生成答案返回用户。**图1**所示为系统架构流程简图：

- 用户 -> 插件/网页问答界面 -> **MCP客户端** (DeepChat 等) -> **大模型 (任务规划)**
   大模型 -> **数据库工具** -> 文档摘要数据库 (检索候选文档)
   大模型 -> **Office文档工具** -> SVN文档库 (读取文档内容)
   大模型 -> 汇总生成答案 -> MCP客户端 -> 前端接口 -> 用户

## 模块与接口设计

以下对各模块的功能、接口输入输出以及实现要点逐一说明。

### 1. 预处理模块

**功能**：扫描 SVN 仓库的更新，提取新文档内容的语义摘要和标签，为后续智能检索建立索引。

**触发**：建议采用**每日定时任务**（如 cron 调度）或 SVN 提交 Hook，在文档有新增或变更后触发处理。

**输入**：SVN 仓库中新增或更新的文档文件。可通过 SVN 命令或API获取变更列表（例如`svn log -r HEAD`定期拉取最近提交）。

**处理流程**：对于每个需处理的文档：

- **内容获取**：通过 SVN 客户端将文档内容提取到本地。例如，对文本/Markdown/代码文件，直接读取文本；对 Office 文档，可结合相应解析库（如 Python 的 `python-docx`、`openpyxl` 等）提取主要文本内容，或借助Office-Editor-MCP进行批量内容提取。
- **摘要生成**：调用公司内部的大模型 API，将文档内容（或片段）传给模型，让其生成该文档的**简明摘要**。摘要应抓取文档的主题、大意和关键点，长度适中便于后续匹配。
- **标签提取**：并行或随后调用大模型的另一个接口，提取文档的**关键词标签**。这些标签可以是反映文档主题的词语、术语（可考虑3-5个标签）。标签提取也可由模型根据内容自动生成，或结合规则提取标题、目录等信息。
- **数据写入**：将文档的元数据存入关系型数据库（如 MySQL/PostgreSQL）。典型地设计 **Document** 表，字段包括：
  - `doc_id`：文档唯一标识（可用 SVN 路径或自增ID）。
  - `path`：文档在 SVN 仓库中的路径或URL。
  - `title`：文档标题或文件名。
  - `summary`：模型生成的摘要文本。
  - `tags`：模型提取的标签（可存为逗号分隔字符串，或设计关联的 Tag 表）。
  - `last_update`：最后更新时间（对应 SVN 提交版本号或时间）。
  - `permissions`（可选）：文档访问权限信息，如所属项目或权限组，用于权限过滤（见下文权限机制设计）。

**输出**：关系数据库中相应记录更新/新增。每次处理完成后，新的摘要和标签将用于问答时检索。通过预处理，**将长文档转换为短摘要索引**，以供大模型高效检索。这利用了LLM对简洁摘要的推理能力，在检索阶段先筛选相关文档，从而避免直接处理整篇长文档的开销。

**实现建议**：

- 使用 **Python** 实现：可利用 `subprocess` 调用 SVN 命令或使用 SVN 库（如 `pysvn`）获取文件，然后用 HTTP 请求调用内部LLM服务（如 REST API）。处理完毕后用 ORM（如 SQLAlchemy）或直接SQL写入数据库。
- 使用 **Java** 实现：可采用 SVNKit 库读取仓库变更，使用公司提供的 LLM SDK 或 REST API 调用模型服务，再通过 JDBC 将结果存入数据库。
- 若公司有内部微服务，可将摘要/标签提取封装为服务接口调用。处理过程建议异步或批量化，以提高效率。

### 2. 问答接口模块

**功能**：作为用户与智能问答系统交互的前端入口。可根据使用场景提供多种形态的接口：

- **网页嵌入**：在现有公司知识库或文档门户网页中集成一个对话窗口组件（Chat Widget），允许用户输入问题并实时得到回答。前端通过 WebSocket 或 HTTP 长连接将问题发送给后台。
- **IDE插件**：为开发者在 IDE 环境（如 VS Code、IntelliJ）中提供查询插件。例如在 VS Code 中，可利用其聊天面板或自定义命令，提问后由插件通过 WebSocket 将请求发送给后台服务，实现代码环境内直接查询文档。

**接口通信**：采用 **WebSocket** 或类似的全双工通信，以支持**流式问答**和状态保持。每个用户会话保持一个连接，发送的数据格式可定义为 JSON，例如：

```json
{ "user_id": "<用户标识>", "question": "<用户的自然语言提问>", "timestamp": 1690000000 }
```

服务器返回回答时，也通过该通道传输：

```json
{ "answer": "<大模型生成的回答文本>", "sources": [<可选，引用的文档列表>], "timestamp": 1690000100 }
```

其中 `user_id` 用于权限校验，`sources` 可选地列出答案参考了哪些文档（用于结果追溯，但前端可选择是否展示）。

**插件实现**：

- **网页端**：使用 JavaScript/TypeScript 开发交互组件，并处理 WebSocket 消息。UI上显示对话记录，支持 Markdown 渲染模型返回的内容（包括表格、代码块等）。
- **IDE端**：VS Code 可直接利用其 Chat 接口或者通过自定义扩展与服务器通信。例如 VS Code 插件可以调用 `vscode.window.createWebviewPanel` 创建对话面板，通过 WebSocket与服务器交互。对Cursor等支持MCP的IDE，也可以直接配置 MCP 客户端（如Cursor内置的 Chat 窗口）连接服务。

**输出呈现**：当答案返回后，接口模块将其渲染给用户。若需要，可以在答案后附带引用文档的名称或链接，方便用户点击查看原文。但需注意权限，若用户无权访问原文档，则不提供链接或提示权限受限。

### 3. MCP客户端模块

**功能**：MCP客户端是连接前端提问与后端大模型/工具的中间件，负责**调度大模型**执行推理，并通过标准协议调用外部工具。可以将其视为**智能代理**，接收用户问题并调用不同模块完成复杂任务。

**实现**：可采用现有 MCP 客户端方案，如 **DeepChat**、**ChatWise** 等开源桌面AI助手，或者在 IDE（如 Cursor、VS Code）的Copilot Chat中启用**Agent模式**。这些客户端支持通过 MCP 与外部服务通讯，使大模型能够发现和调用预先配置的工具。若使用 Cursor IDE，本方案可以在 Cursor 设置中将自研的数据库检索和Office读取功能配置为 MCP 工具，供大模型调用。

**主要职责**：

- **模型调用**：与公司内大模型 API 集成。客户端将用户提问包装为模型可理解的Prompt（包含必要的系统指令、上下文），调用大模型服务获取回复。对于Agent模式，大模型可能多轮调用工具才能得到最终答案，MCP客户端需支持**流式交互**。
- **工具管理**：根据MCP协议，向大模型**声明可用的工具**集合，包括“数据库检索工具”和“文档读取工具”等。客户端监听模型的指令，如果模型请求调用某个工具（例如要求查询数据库或打开文档），客户端就按照协议与相应的 MCP服务端交互，获取结果再反馈给模型。
- **会话维护**：跟踪一次用户问答过程中模型调用工具的中间状态。确保多轮交互在同一会话上下文中进行，直到模型生成最终答案。
- **结果返回**：将最后生成的答案封装并通过 WebSocket传回问答接口模块。

**接口规范**：MCP采用统一的消息格式，一般为 JSON-RPC 或类似结构。例如，当模型需要使用工具时，客户端会收到类似：

```json
{ "tool": "doc_search", "params": {"query": "关键词"}, "action": "invoke" }
```

然后客户端调用对应服务端并将结果返回模型。开发中可参考 MCP 标准文档或利用开源 SDK（如官方 C# MCP SDK或 Python 实现）快速对接。

**DeepChat示例**：DeepChat 作为MCP客户端，支持多模型接入和工具调用。配置本方案的 MCP 服务后，DeepChat 能够通过 **MCP 协议连接文件系统、数据库等工具**，实现本地知识库问答。这意味着开发者和普通用户都可以在统一界面，通过 AI 查询SVN文档而无需离开当前工作环境。

### 4. 大模型任务拆解模块

**功能**：大模型负责理解用户的自然语言问题，并**规划求解策略**。针对复杂问题，大模型需要拆分为检索和阅读等子任务，然后逐步完成。

**语义解析**：模型首先基于训练的知识和Prompt指令，对用户问题进行语义分析，确定问题涉及的主题、可能关联的文档类型或位置。例如，问题可能询问某项目的设计方案细节，则模型判断需要检索与该项目设计相关的文档。

**任务规划**：解析后，模型生成一系列**操作步骤**：

- **检索**：模型构造查询条件，如根据问题提取的关键词或推断的标签。这里可采用显式提示方式：“从知识库中搜索关于X的文档。”模型会返回相应的查询（可能是SQL片段或关键词列表）。
- **阅读**：模型决定需要阅读哪些具体文档来获取答案细节。当检索出候选列表后，模型评估摘要，挑选出最相关的文档（或段落）并请求获取全文内容。
- **回答**：在收集足够信息后，模型整理并生成最终的自然语言答案，可能引用文档中的要点。

**实现**：

- **提示词工程**：在系统Prompt中嵌入指导，如：“你可以访问一个文档数据库工具（doc_search）来查找摘要标签匹配的文档，然后用文档阅读工具（doc_open）打开文档内容进行分析。” 这样模型知道何时调用工具以及如何使用结果。

- **显式API调用**：另一方式是**不使用Agent自由规划**，而通过后端逻辑分步调用模型。例如：

  1. **提取查询**：调用一次模型：`“根据问题提取检索关键词/标签:”`，模型输出可能的搜索词。
  2. **查询数据库**：代码使用模型输出的关键词在SQL中 `LIKE` 或全文索引查询匹配摘要/标签。
  3. **读取文档**：将查询结果列表及问题一起发送给模型，请其选择最相关的文档编号。然后程序调用SVN获取该文档内容。
  4. **答案生成**：最后再调用模型，让其根据问题和提取的文档内容生成答案。

  此显式多步流程，每一步都是固定的 API 调用，使过程更可控。不过相对Agent模式缺少模型自主决策的灵活性。

**关键算法建议**：

- **关键词/标签匹配**：可使用模型生成的标签直接比对，也可对问题做简单分词提取名词。如果使用向量语义匹配，可以将摘要文本嵌入向量，在查询时将问题投向量空间找最近的摘要（但实现会更复杂，需要向量数据库支持）。
- **相关度排序**：当数据库返回多个候选摘要，若未用向量，则可根据关键字匹配度或摘要长度等打分，或再询问模型哪个摘要最相关，由模型打分。
- **渐进式阅读**：针对长文档，不一定全文都读给模型。可以让模型先浏览摘要决定是否需要细节，再通过 Office-Editor-MCP 提供的搜索功能查找文档内相关段落。Office-Editor-MCP 支持**提取文本**和**分析文档结构**，模型可利用这些能力定位答案区域，减少不必要的阅读量。

**输出**：经过任务拆解和执行，输出给最终用户的是模型的答案文本。对于多轮对话，模型的内部规划步骤对用户透明，只呈现最后结果（或者可以在开发模式下输出调试信息用于改进提示词）。

### 5. 数据库检索模块

**功能**：根据大模型的查询意图，在关系型数据库中检索**候选文档摘要**，并执行**权限过滤**。

**数据库选型**：使用成熟的关系数据库（MySQL、PostgreSQL 等）。由于数据主要是文档元信息和摘要，数据量取决于文档数量和摘要长度，一般关系型数据库足够胜任。必要时可在摘要字段上建立**全文索引**(Fulltext Index)以加速查询。

**检索接口**：可设计为 MCP 服务端工具（如 "DocSearch Server"）供模型直接通过自然语言调用。例如模型请求`doc_search("项目Alpha 设计 文档")`，服务端将解析出SQL查询执行并返回结果。或者由后台控制逻辑直接查询数据库然后把结果提供给模型。

**查询策略**：

- **匹配字段**：主要匹配摘要文本 (`summary`) 和标签 (`tags`) 字段。使用SQL的 `MATCH ... AGAINST` (全文检索) 或 `LIKE` 查询。如果标签单独存表，可join或先查Tag表。
- **模糊/语义查询**：可以允许模型传入自然语句，然后服务器在SQL层面做简单处理（如空格拆词多关键词LIKE）。若需要更智能，可引入向量检索（将summary向量预存，查询时对问题向量最近邻），但这超出需求范围。
- **结果集**：返回包括文档标识、标题、摘要、匹配度等。例如返回前 N 条最相关摘要。

**权限过滤**：**关键步骤**，在SQL查询中加上用户权限限制：

- 数据库需要存储或能够获取每份文档的权限信息。可在 Document 表中增加字段 `access_level` 或 `owner_group`，或者建立**DocumentPermission**表：每条记录包含 `doc_id` 和 `user_id`/`group_id`，表示该用户/组可访问该文档。

- 在查询时，根据当前提问用户的身份（已通过`user_id`传递），添加筛选，例如：

  ```sql
  SELECT * FROM Document d 
   JOIN DocumentPermission p ON d.doc_id = p.doc_id 
  WHERE p.user_id = :uid 
    AND (d.summary LIKE '%关键词%' OR d.tags LIKE '%关键词%')
  ORDER BY d.last_update DESC;
  ```

  这样只会返回用户有权限的文档。若使用组权限，可先查询出用户所属组列表，再在条件中匹配。

- SVN 的权限通常基于仓库路径定义。可在预处理时解析 SVN 的授权配置(authz文件)，将每个路径的可访问用户/组存入权限表。**SVN 原生支持基于路径的权限控制**，这一机制可被利用。

**输出**：检索模块将**候选文档列表**返回给大模型或后端逻辑。结果可以是简短JSON数组，例如：

```json
[
  { "doc_id": 101, "title": "Alpha项目设计.docx", "summary": "…摘要内容…", "score": 0.95 },
  { "doc_id": 78, "title": "Alpha项目计划.md", "summary": "…摘要内容…", "score": 0.85 }
]
```

模型据此决定下一步动作（如要求阅读某个 doc_id）。

**实现建议**：如果采用 MCP Server 形式，可以用 Python 搭建一个小型HTTP服务，接收自然语言查询并转换为SQL执行。为了安全，需防范直接SQL拼接造成的注入，可限定只搜索摘要和标签字段，或对输入关键词做净化。Java实现则可将查询封装为一个Service，由MCP客户端调用相应方法。测试时要确保大量文档时查询性能，可对 summary 列建立索引或采用全文检索引擎（MySQL InnoDB FTS或ElasticSearch等）提升速度。

### 6. SVN文档访问模块

**功能**：根据需要读取 SVN 仓库中的原始文档内容，让大模型深入分析以生成最终答案。

**工具选型**：本方案采用 **office-editer-mcp** 作为 Office 文档读取工具。它实现了 MCP 标准，可以接受AI助手请求来打开和读取 Word、Excel、PPT 等文件内容。对于纯文本文件（如 Markdown、代码文件），也可以配置一个 **文件系统MCP服务器** 或直接由后台程序读取文件内容提供给模型。

**部署**：将 office-editor-mcp 以独立服务方式部署（Python实现，支持stdin/stdout或HTTP模式）。然后在 MCP客户端配置中注册该服务。例如在 Cursor 中 `.cursor/mcp.json` 配置一个 server：

```json
{
  "name": "OfficeDocServer",
  "type": "stdio",
  "command": "python /path/to/office_server.py"
}
```

这样AI助手即可通过名称调用Office文档工具。

**文档获取流程**：

1. **定位文档**：模型或后端传入要打开的文档标识（如 `doc_id` 或直接文件路径）。如果只有 `doc_id`，后台先从数据库查出对应的 SVN 路径。
2. **获取文件**：需要将 SVN 仓库中文档内容提供给 Office-MCP 工具。可采用**本地镜像**策略：预处理阶段或定时任务维护一份 SVN 工作副本（Working Copy）在服务器本地，不断 `svn update` 保持最新。这样就能通过本地文件路径直接打开文档。而无需每次联网请求 SVN。
   - 若无法维护完整镜像，也可在调用时使用 `svn export` 或 `svn cat` 将文件下载到临时目录，然后让工具打开。但频繁调用性能较低。
3. **工具读取**：Office-Editor-MCP 提供API来**提取文档文本**。当AI调用例如 `word.read(file="...")` 时，MCP服务器会打开该 Word 文档并返回其纯文本内容或结构化内容。Excel、PPT 类似（返回表格数据或幻灯片文本）。
   - 由于MCP服务器已对Office格式做了解析，在使用时只需确保传入正确的文件路径，和相应的读取命令。也可以先让模型调用该工具的“list content”功能查看文档大纲，再逐段读取特定部分，以避免一次获取全文过长。
4. **结果返回**：MCP服务器将文档内容（或片段）返回给大模型。格式可能是长文本，模型将其纳入上下文。
5. **模型生成**：模型结合文档内容和原始问题，进行分析总结，产出答案。例如，模型可能找到文档中的某章节包含答案，并据此用自己的语言回答用户问题。

**注意**：需要限制单次发送给模型的内容长度，避免超过模型上下文窗口。若文档非常长，可采用**分段阅读**：让模型先获取文档概要（office-editor-mcp可能支持提取文档摘要或目录），然后指导其逐步深入所需部分。例如让模型执行“在文档中查找‘关键词’”以定位答案附近内容，再读取该部分文本。

**输出**：此模块本身输出给模型的是文档的文本内容或其中的相关数据。最终用户不会直接看到全文，只会看到模型依据内容给出的答案。若需要增强可信度，可以在答案中附带引用如“（来源：XXX文档）”，但这取决于产品需求。

**实现建议**：

- **权限配合**：在实际读取前，后台应再次核验用户对该文档是否有读取权限（防止模型绕过SQL过滤直接请求不该看的doc）。可在调用office-editor之前检查用户ID是否在DocumentPermission表中具有权限，无则拒绝调用或返回空内容。
- **错误处理**：如果文档因权限或不存在导致读取失败，MCP服务器应返回错误信息，模型据此回答类似“我无法访问该文档”或“未找到相关信息”。要避免模型将权限不足的提示误作为内容，系统可以在MCP客户端层拦截无权限错误并直接告知用户无权限。

### 7. 权限控制与追溯机制

**权限控制**：方案严格遵循 SVN 原有的权限配置：

- **用户身份获取**：用户登录问答接口时，必须获得其身份（如通过单点登录获取用户名/工号）。所有后端请求都应附带此 `user_id` 用于权限验证。
- **数据库过滤**：如前所述，在检索阶段仅返回用户授权的文档摘要。这样后续即使模型尝试打开未授权文档，也拿不到对应的 doc_id。此为**第一道防线**。
- **文档读取验证**：在实际调用 SVN 文档读取时，加入**第二道防线**。后台核对用户对目标文档的访问权限。实现上可简单查询 DocumentPermission 表，或调用 SVN 服务接口验证。如果发现无权限，拒绝提供内容，并记录违规请求。
- **最小暴露原则**：即使用户有权限，也尽量**只回答问题相关的内容**，不把整份文档泄露。模型生成答案时应遵循这个原则，比如只给出结论或片段，而非整页摘抄（可以在系统提示中强调遵守信息边界）。

**日志追溯**：为保证问答可审计、结果可信，需要完善日志：

- **问答日志**：记录每次提问的 `user_id`、问题文本、时间戳，以及**模型给出的最终答案**。可选地也记录会话ID用于串联多轮对话。
- **数据来源日志**：记录每次问答过程中使用到的文档。例如存储 `question_id` 对应查阅了哪些 `doc_id`。可以在模型每次调用检索和打开文档工具时，由MCP客户端拦截记录。这形成**引用链**，日后能够查看某答案用了哪些文件信息支撑。
- **系统日志**：记录各模块的异常情况，如无法连接模型服务、数据库错误、权限拒绝等，方便排查问题。

这些日志可以存在关系库中如**QALog**表，字段包括：id, user, question, answer, timestamp 等；另有**QALog_DocRef**表列出 (log_id, doc_id)。由于涉及内容敏感，日志存储和访问也需要权限控制，仅管理员或审计人员可查看。

**安全审计**：定期检查问答日志，看看是否有用户查询了敏感文档、或者模型回答中是否包含不该泄露的信息。如果发现问题，可追踪对应文档来源和用户操作记录（得益于SVN也保存了修改历史，可双向印证）。

**合规和水印**：如果公司有保密要求，甚至可考虑给模型返回的答案加上水印或标记来源（比如在答案最后注明“来源于内部文档，不得外传”）。尽管模型本身是内部的，但防止用户复制答案外泄也是一环。

## 关键实现细节与建议

结合上述模块说明，以下补充一些整体性的实现建议：

- **模块集成顺序**：可先开发和测试预处理（建立文档摘要库），再搭建问答流程。在无模型接口时，可用简单关键词搜索+模板回答验证端到端流程。随后接入模型，提高回答智能性。
- **并发与性能**：预处理应尽量增量更新，每日运行时间窗口内完成当天变更解析即可。问答部分需要支持多用户同时查询，MCP客户端和模型服务应具备并发能力。可以部署多个MCP客户端实例或使用异步IO模型。数据库索引优化保证查询瞬时返回。Office-MCP 打开文档相对耗时，可考虑对常被问到的文档缓存其文本内容以加速读取。
- **模型选择与调用**：公司内模型API应该提供高可靠性。若模型对每次工具使用都要远程调用，网络延迟和稳定性要考虑。为了减轻模型负担，对于非常简单的问题（例如Exact字符串匹配能直接从摘要库得到答案），系统可直接回应或使用小模型，以降低大模型调用成本。
- **错误处理**：设计友好的fallback机制。当大模型失效或API超时时，可以反馈“很抱歉，我暂时无法获取答案”。若Office文档解析失败（例如文件损坏），记录错误并通知相关人员修复数据。
- **前端体验**：问答界面可以支持上下文对话，允许用户追问细节。实现上，可以将同一会话历史（最近几问答和引用文档摘要）一并传给模型，提升上下文理解。但也要注意不要引入无权限的旧内容。

## 数据表设计建议

综合上述需求，数据库设计上至少包含如下主要表：

- **Document(doc_id, path, title, summary, tags, last_update, access_level)** – 存储文档元数据及索引信息。`access_level`可用于简单权限（如公开/内部/私密），或存储权限分组名称。
- **DocumentTag(doc_id, tag)** – （如果需要更规范地存标签）每行一个标签，方便针对标签查询。或者用一张 Tag 表规范标签词汇。
- **DocumentPermission(doc_id, user_id)** – 定义用户级权限。如果权限以组控制，则可为 (doc_id, group_id)，并有 UserGroup(user_id, group_id) 表维护用户与组关系。
- **QALog(log_id, user_id, question, answer, ask_time)** – 记录问答主表。
- **QALogDoc(log_id, doc_id)** – 记录一次问答涉及到的文档（通过 doc_id 关联 Document 表）。如有多个文档则有多行。
- **User(user_id, name, dept, ...)** – 用户信息表，可选，至少需要存用户与其权限组的关系。如果已有用户系统，可从中对接，而无需新建。

此外，可能还有**AuditTrail**表记录系统内部重要事件（如权限被拒绝情况，系统错误等）。

**索引**：在 Document 表的 `summary` 和 `tags` 字段上建立全文索引(如 MySQL `FULLTEXT(summary, tags)`)，以提高模糊查询速度。在 DocumentPermission 上对 user_id 建立索引，以便按用户过滤高效。

**容量规划**：摘要通常较短（几百字以内），即使上万篇文档数据量也不大，关系库可轻松容纳。QALog按需清理历史（比如只保留近1年的问答记录归档），以防无限增长。

## 权限过滤机制建议

为了确保权限控制万无一失，可以考虑在**应用层**再增加一层过滤校验：

- **问题过滤**：根据用户的角色或部门，对问题本身进行敏感词检测。如果用户试图询问明显超出其权限范围的内容（比如某些密级关键词），系统可直接拒绝回答或者给出警告。这属于**静态权限策略**，在问题提交时即可拦截。
- **答案过滤**：对模型返回的答案进行扫描，检查是否包含用户无权查看的信息。实现上可以将答案中的片段与文档摘要库或权限表比对。如果发现模型可能“泄露”了未经授权的信息，则拦截回答并返回通用提示（如“无权访问该信息”）。这比较复杂但增加一层保险。
- **工具级权限**：通过 MCP 协议可以为工具配置作用域。例如我们的数据库检索工具可以内部限定查询只在特定项目范围内（根据用户身份传入不同库视图）。Office读取工具也可增加认证步骤，例如要求传入token才能打开文件。

## 关键算法和技术方案总结

- **文档摘要提取**：利用大模型强大的概括能力，预先生成文档摘要索引，解决长文档直接检索难的问题。该摘要索引结合标签，为后续**LLM语义检索**提供了基础。
- **LLM语义检索**：通过将简洁的文档摘要提供给LLM来判断相关性，比传统关键词匹配更加智能，同时避免了直接处理全文的高成本。这是一种折中方案，在语义搜索和全文检索之间取得平衡。
- **MCP工具集成**：采用 Model Context Protocol 打通模型与外部系统。通过标准协议，让大模型可以像调用函数一样使用数据库和文件读取功能。这种架构减少了定制集成的工作，具有灵活扩展性：未来如需增加对其他类型知识库或工具（如邮件、Wiki）的支持，只需实现相应 MCP Server 并配置给客户端即可。
- **权限与安全**：充分利用 SVN 的原生权限体系并在应用层多次校验，确保**只提供用户可访问的知识**。配套详尽的日志，实现结果可追溯，满足企业内控要求。

## 结论

本方案提供了一个**基于AI增强的 SVN 文档库**完整实现思路。在保留现有 SVN 管理模式的同时，引入大模型对用户查询进行智能解析，利用预处理摘要和权限校验机制，实现准确、高效且安全的文档问答服务。通过模块化设计（预处理、检索、阅读、问答）和 MCP 标准，方案具备良好的扩展性和可维护性。开发完成的系统可以作为插件或独立网页提供给终端用户，并附带源码、部署文档和使用说明，方便安装和推广。此举将大幅提升企业内部文档知识的获取效率，让员工能够自然地从海量 SVN 文档中获取所需信息，达到知识库与AI融合的目标。